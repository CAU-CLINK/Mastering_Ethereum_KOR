[[tokens_chapter]]
== Tokens


((("tokens", id="ix_10tokens-asciidoc0", range="startofrange")))"토큰"이라는 단어는 sign 또는 symbol을 의미하는 고_영어 "tācen," 으로부터 유래되었다. transportation, 세탁 그리고 아케이드 게임 토큰 같은 사적으로 발행됐고 특별한 목표를 가진 coin-like 한 아이템의 insignificant intrinsic 한 value를 칭하는데 주로 사용된다.

요즘, 블록체인에서 관리되는 "토큰들"은 자산, 통화 그리고 액세스 권한같은 소유될 수 있는 블록체인 기반이라는 단어의 모호함을 재정의한다.(?)

"토큰"이라는 단어와 insignificant value 의 관계는 토큰의 물리적 버전의 한계적인 사용과 많은 관련이 있다.(?)가끔 특정 분야의 사업, 조직 혹은 위치에 제한된 physical token 들은 교환되기 쉽지 않고, 전형적으로 1개의 기능만을 가지고 있다. 블록체인 토큰은 이러한 제한들을 lift 할 수 있거나 더 정확히는 완벽하게 재정의 할 수 있다. 많은 블록체인 토큰들은 많은 목적들을 globally 하게 제공할 수 있고 서로서로 다른 화폐로 global liquid market 에서 교환될 수 있다. 사용에 있어서 제한이 없어지고 소유권이 없어지면서, "insignificant value" 에 대한 기대 역시 옛 것이 되었다.(?)

이번 챕터에서는, 토큰의 다양한 사용법과 그들이 어떻게 생성되는지에 대해서 알아보려고 한다. fungibility 나 intrinsicality 와 같은 토큰의 특징들에 대해서도 알아보려고 한다. 그리고 우리는 그들이 기반으로 하는 표준과 기술을 시험하고 우리만의 토큰을 만들어보려고 한다.(??)

[[tokens_use]]
=== How Tokens Are Used

((("tokens","uses of", id="ix_10tokens-asciidoc1", range="startofrange")))토큰의 가장 obvious한 사용처는 디지털 private 통화이다. 그러나, 이거는 오직 한가지 가능한 방법이다. 토큰들은 서로 다른 많은 함수들을 기능을 제공할 수 있게 프로그래밍 될 수 있다, 때로는 겹치게도 할 수 있다. 예를 들어, 토큰은 투표권, 접근 권한 그리고 리소스에 대한 ownership 을 동시에 convey 할 수 있다. 다음 목차에서 보이듯이, 통화는 가장 첫 "app"일 뿐이다 : 

통화 (Currency) :: 토큰은 통화의 형태로 제공될 수 있다, private trade를 통해서 가치가 결정된다. 

리소스 (Resource) ::  토큰은 공유 경제 또는 resource-sharing 환경에서 생산되거나 취득될 수 있는 resource 를 대표할 수 있다 ; 예를 들면, storage 또는 CPU 토큰은 네트워크를 통해서 공유될 수 있는 resources 를 대표한다. 

자산 (Asset):: 토큰은 본질적이고 외인적인 소유권, 구체적이거나 추상적인 자산의 소유권을 대표할 수 있다 : 예를 들면, 금, 부동산, 차, 기름, 에너지, MMOG 아이템 기타등등

접근 (Access):: A token can represent access rights and grant access to a digital or physical property, such as a discussion forum, an exclusive website, a hotel room, or a rental car.

증권 (Equity):: 토큰은 디지털 조직(e.g, DAO) 또는 법적인 entity(e.g, corporation) 에서 주주 증권성(?)을 나타낼 수 있다. 

투표권 (Voting):: 토큰은 디지털이나 법적 시스템에서 투표권으로써 사용될 수 있다.

Collectible:: A token can represent a digital collectible (e.g., CryptoPunks) or physical collectible (e.g., a painting).

Identity:: A token can represent a digital identity (e.g., avatar) or legal identity (e.g., national ID).

Attestation:: A token can represent a certification or attestation of fact by some authority or by a decentralized reputation system (e.g., marriage record, birth certificate, college degree).

Utility:: A token can be used to access or pay for a service.

가끔, 하나의 토큰이 다양한 이 기능들을 관철할 수 있다. 가끔 그것들을 구분하기 힘들다, 물리적 등가성이 항상 불가분하게 연결되어 있기 때문이다. 예를 들면, 물리적 세계에서는, 운전 면허증(attestation)은 신분증(identity)이고 이 둘은 분리될 수 없다. 디지털 환경에서는, 이전에는 혼합되어 있던 이 기능들이 분리되고 독자적으로 발전할 수 있다.(e.g., anonymous attestation)(((range="endofrange", startref="ix_10tokens-asciidoc1")))

[[tokens_fungibility]]
=== 토큰과 분할 가능(Fungibility)

((("fungible tokens", seealso="ERC20 token standard")))((("tokens","fungibility")))https://en.wikipedia.org/wiki/Fungibility[Wikipedia] says: "경제학에서는, 분할 가능성은 개별적인 unit들이 본질적으로 교환가능한 물품이나 재화의 특징이다."(?) 

토큰은 그것의 가치 또는 기능의 차이없이 한 가지에서 다른 것으로 바꿀 수 있을 때 fungible 하다. 

엄격하게 하면, 만약 토큰의 historical provenance가 추적가능하면, 그 토큰은 완벽하게 fungible 한 것은 아니다. provenance를 추적할 수 있는 능력은 blacklisting 그리고 whitelisting 으로 이어질 수도 있고 이는 fungibility 를 줄이거나 없앨 수 있다.(?) 

((("non-fungible tokens (NFTs)"))) Non-fungible 한 토큰들은 각각이 고유한 맹백한 또는 추상적인(?) item을 대표하고 그러므로 상호 교환이 불가능하다. 예를 들어, _특정한_ 반고흐 그림의 소유권을 나타내는 토큰과 피카소 그림의 소유권을 나타내는 토큰은 같을 수 없다. 설사 그 둘이 모두 "예술 작품의 소유권 토큰"을 나타내는 것이라고 할지언정. 비슷하게, 특정 Cryptokitty 같이 _특정한_ 디지털 소장품을 나타내는 토큰은 다른 크립토키티와 교환할 수 없다.(?) 각각의 non-fungible한 토큰은 특정 identifier 와 연관이 있다, serial number 같은 것이다.

fungible 한 것과 non-fungible 한 토큰의 예시를 이 단원 끝에서 볼 것이다. 

[NOTE]
====
"fungible" 이라는 말은 때론 "돈과 직접적으로 교환 가능함" 이라는 의미로 쓰이기도 한다.(예를 들면, 카지노 토큰은 "cashed in" 될 수 있다, laundry token 전형적으로 안되는 것이다). This is _not_ the sense in which we use the word here.
====

[[counterparty_risk]]
=== Counterparty Risk

((("counterparty risk")))((("tokens","counterparty risk")))Counterparty risk 는 거래의 상대방이 그 의무를 만족하지 못할 때 나타나는 위험이다. 둘 이상의 주체가 포함된 특정 타입의 거래들은  추가적인 counterparty risk 를 야기한다. 예를 들어, 귀금속에 대한 보증금의 certificate을 너가 보유하고 있고, 너가 그거를 다른 사람에게 판다고 한다면, 최소한 그 거래에는 3개의 당사자가 생긴다 : 판매자, 구매자, 그리고 그 귀금속의 custodian 이다. 물리적 자산을 보유한 누군가가 있다 ; necessity 에 따라 그들은 거래의 fullfillment 가 되고 그 자산이 포함된 그 어느 거래에서도 counterparty risk 가 더해진다. 주로, 토큰의 소유권의 교환에 따라 자산이 비간접적으로 거래가 되면 자산의 custodian 으로 부터 추가적인 counterparty risk 가 생기게 된다. 그들이 자산을 가지고 있는가? 그들이 토큰의 이동을 기반으로 한 소유권의 거래를 인식하는가?(증명서, deed, title 또는 디지털 토큰) 디지털 토큰이 자산을 대표하는 세계에서는 ,as in the nondigital world, 토큰이 나타내는 자산을 누가 소유하는가 그리고 그 자산에 적용되는 규칙을 이해하는 것이 중요하다.(????) 

[[tokens_intrinsicality]]
=== Tokens and Intrinsicality

((("tokens","intrinsicality")))"내재적"이라는 단어는 라틴어 "from within" 이라는 의미를 가진 "intra"라는 단어에서 파생되었다.

몇몇 토큰들은 블록체인에 내재되어있는 디지털 상품들을 대표한다.(?) 그 디지털 자산들은 토큰과 마찬가지로 합의 규칙(consensus rules)에 의해 관리된다. 이는 중요한 점을 암시한다 : 내재적 가치를(assets) 대변하는 토큰들은 추가적인 거래 상대 리스크를 야기하지 않는다.(counterparty risk) 만약 당신이 CryptoKitty 의 키를 가지고 있다면, 그 CryptoKitty를 관리해주는 다른 주체는 존재하지 않는 것이다. 당신이 스스로 그것을 관리하는 것이다. 블록체인 합의 규칙이(consensus rule) 적용되고 프라이빗 키의 소유권은 자산의 소유권과 동일하게 된다. 중개자는 없다.(?)

반대로, 부동산, coporate voting shares, 트레이드 마크(trademarks) 그리고 골드바와 같은 _extrinsic_ 것을 대표하는 토큰들도 많이 쓰이고 있다.  이러한 것들의 소유권은 블록체인에 들어있지 않고, 법, custom, 정책에 의해 통제되며 토큰을 통제하는 합의 규칙과 분리되어 있다. 즉, 토큰 발행자와 소유자는 실세계의 non-smart contracts에 여전히 의존한다. 결과적으로, 이러하 외인적인 자산들은 더 많은 상대방 리스크(counterparty risk)를 야기한다. 왜냐하면, 그것들은 후견인(custodian)에 의해 관리되고, 외부에서 기록되고(?) 블록체인 환경 외부의 법과 정책에 의해서 관리되기 때문이다. 

블록체인 기반의 토큰들의 ramification 중 가장 중요한 것은 외인적인 자산을 내재적 자산으로 바꾸어 counterparty risk 를 없애는 것이다. corporation(extrinsic)에서의 equity 에서 _DAO_ 혹은 그와 비슷한(내재된) 기관에서의 equity 혹으 투표 토큰으로 바뀌는 것이 중요한 예이다.

[[using_tokens]]
=== 토큰 사용하기(Using Tokens) : 유틸리티와 에퀴티 (Utility or Equity)

((("tokens","utility/equity types", id="ix_10tokens-asciidoc2", range="startofrange")))오늘날의 이더리움 기반의 거의 모든 프로젝트들은 토큰 같은 것을 가지고 런칭한다. 그런데 정말 그 모든 프로젝트들이 토큰이 필요할까? 토큰을 사용하는데 있어서 불이익이 있을까? 혹은 "모든 것을 토큰화한다" 라는 슬로건이 현실이 될까? 원칙적으로, 토큰의 사용은 최고의 조직 관리(management or organization) 방법으로 보일 수 있다. 현실적으로, 지금까지는 기존 사회 구조에(structures of existing of society means) 이더리움을 포함한 블록체인 플랫폼을 적용하는 것은 그 applicability 에 많은 제약이 있음을 의미한다.

새로운 프로젝트에서 토큰의 역할을 정확히 명시화 하는 것부터 시작하자. 대부분의 프로젝트에서는 토큰을 2가지 방법으로 사용한다 : "utility 토큰" 아니며 "equity 토큰" 이다. 아주 가끔 2개의 역할이 합쳐지기도 한다. 

((("utility tokens","defined"))) 유틸리티 토큰은 서비스, 어플리케이션 혹은 리소스에 대한 권한을 얻기 위해서 사용된다. 공유 저장소같은 리소스나 소셜 미디어 네트워크 서비스에의 접근 권한 등을 대표하는 것이 유틸리티 토큰의 예이다. 

((("equity tokens","defined")))Equity tokens은 start up 과 같은 어떤 것의 소유권이나 통제권의 몫을 나타낼 때 쓰인다. Equity token 은 배당금이나 이이 분배와 같은 무투표 share 에 한정된다, 혹은 토큰 홀더들의 투표르 기반으로하 복잡한 거버넌스 시스템을 통해 통제되는 DAO 에서의 투표권으로 확장될 수 있다.

[[its_not_duck]]
==== 오리닷! (It's a Duck!)

((("equity tokens","utility tokens as")))((("utility tokens","equity tokens disguised as"))) 많은 스타트업들은 어려운 문제를 직면했다.: 토큰은 훌륭한 모금 수단이지만, 대중에게 증권(주식)을 제공하는 것은 대부분 사법권 안의 규제된 행동이다.(?) equity 토큰을 utility 토큰으로 변장함으로써, 많은 스타트업들은 이 규제를 피하고 "서비스 접근 바우처의 pre-sale 로 대표되는 public offering 으로 금액을 모으고 싶어한다. 이처럼 얕게 위장된 equity offering 은 규제기관들을 skirt 할 수 있는지는 아직 지켜봐야 한다. (??)

유명한 말이 말하듯 : "If it walks like a duck and quacks like a duck, it's a duck." 규제기관들은 이런 의미론적인 왜곡(semantic contortions)에 의해 주의를 빼앗기지 않는다; 완전 반대다, 그들으 대중을 기만하려는 법적인 궤변을 볼 가능성이 높다.(?)

[[who_needs_utility_tokens]]
==== Utility Tokens: Who Needs Them?

((("utility tokens","issues to consider when using", id="ix_10tokens-asciidoc3", range="startofrange")))진짜 문제는 스타트업들에게는 유틸리티 토큰 도입에 심각한 리스크와 진입 장벽(적용 장벽?)이 있다는 것이다. 아마도 먼 미래에는 "모든 것을 토큰화"한다는 것이 현실이 될 것이다, 그러나 지금으로썬 이에 대한 이해와 토큰을 사용하고 싶어하는 사람들은 안그래도 작은 암호화폐 시장에서도 일부이다.  

스타트업들에게는, 모든 혁신이 리스크와 market filter를 동반한다. 혁신은 남들이 잘 가지 않았던 길을 가는 것이고 전통적인 방법과는 다른 것을 채택하는 것이다. 이미 외로운 길이다. 만약 스타트업이 신기술 분야에서 P2P 네트워크를 통한 저장소 공유와 같은 혁신을 해보려고 한다면, 엄청나게 외로운 길이다.(?) 그러한 혁신에 유틸리티 토큰을 도입하고 사용자들에게 이 서비스를 사용하려면 토큰을 사용하라고 요구하는 것은 위기를 합치는 것이고 적용 장벽을 높이는 것이다. 이는 안 그래도 외로운 p2p 저장 혁신의 길에서 이것도 벗어나 완전 광야로 나가는 것을 의미한다.

모든 혁신을 필터로 생각해라. 이는 혁신의 얼리 어답터가 될 수 있는 시장의 subset으로 채택을 제한한다.(?) 2번째 필터를 더하는 것은 그 효과를 합치는 것이다, addressable 한 시장으로 한정짓는다. 얼리어답터가 되기 위해서는 1가지가 아닌 2가지의 완벽하게 새로운 기술을 더해야 한다. : 당신이 만든 참신한 어플리케이션 / 플랫폼 / 서비스 그리고 토큰 이코노미 

For a startup, each innovation introduces risks that increase the chance of failure of the startup. If you take your already risky startup idea and add a utility token, you are adding all the risks of the underlying platform (Ethereum), broader economy (exchanges, liquidity), regulatory environment (equity/commodity regulators), and technology (smart contracts, token standards). That's a lot of risk for a startup.

Advocates of "tokenize all the things" will likely counter that by adopting tokens they are also inheriting the market enthusiasm, early adopters, technology, innovation, and liquidity of the entire token economy. That is true too. The question is whether the benefits and enthusiasm outweigh the risks and uncertainties.

Nevertheless, some of the most innovative business ideas are indeed taking place in the crypto realm. If regulators are not quick enough to adopt laws and support new business models, entrepreneurs and associated talent will seek to operate in other jurisdictions that are more crypto-friendly. This is already happening.

Finally, at the beginning of this chapter, when introducing tokens, we discussed the colloquial meaning of "token" as "something of insignificant value." The underlying reason for the insignificant value of most tokens is because they can only be used in a very narrow context: one bus company, one laundromat, one arcade, one hotel, or one company store. Limited liquidity, limited applicability, and high conversion costs reduce the value of tokens until they are only of "token" value. So when you add a utility token to your platform, but the token can only be used on your single platform with a small market, you are recreating the conditions that made physical tokens worthless. This may indeed be the correct way to incorporate tokenization into your project. However, if in order to use your platform a user has to convert something into your utility token, use it, and then convert the remainder back into something more generally useful, you've created a company scrip. The switching costs of a digital token are orders of magnitude lower than for a physical token without a market, but they are not zero. Utility tokens that work across an entire industry sector will be very interesting and probably quite valuable. But if you set up your startup to have to bootstrap an entire industry standard in order to succeed, you may have already failed.

[NOTE]
====
One of the benefits of deploying services on general-purpose platforms like Ethereum is being able to connect smart contracts (and therefore the utility of tokens) across projects, increasing the potential for liquidity and utility of tokens.
====

((("tokens","reasons to adopt")))Make this decision for the right reasons. Adopt a token because your application _cannot work without a token_. Adopt it because the token lifts a fundamental market barrier or solves an access problem. Don't introduce a utility token because it is the only way you can raise money fast and you need to pretend it's not a public securities offering(((range="endofrange", startref="ix_10tokens-asciidoc3"))).(((range="endofrange", startref="ix_10tokens-asciidoc2")))

[[token_std]]
=== 이더리움에서 토큰 (Tokens on Ethereum)

((("tokens","on Ethereum", id="ix_10tokens-asciidoc4", range="startofrange")))블록체인 토큰은 이더리움 이전에도 존재했다. ((("Bitcoin","as token")))어떤 면에서 보면, 첫 블록체인 통화 비트코인 그 자체도 토큰이다. 많은 토큰 플랫폼들은 비트코인과 이더리움 이전의 다른 암호화폐를 기반으로 개발되었다. 그러나 이더리움의 첫 토큰 표준 배포가 토큰의 폭발적인 성장을 가져왔다. 

((("Buterin, Vitalik","on tokens")))비탈릭 뷰테린은 이더리움처럼 일반화되어있고 프로그래밍 할 수 있는 블록체인에서 토큰들을 가장 분명하고(obvious) 유용한 어플리케이션이라고 하였다. 사실, 이더리움 초창기에는 비탈릭과 나머지 사람들이 이더리움 로고와 스마트 컨트랙트 샘플이 뒷면에 박힌 티셔츠를 입고 다니는 것을 자주 볼 수 있었다. 다양한 버전의 티셔츠가 있었지만, 제일 흔한 것은 토큰 도입이었다.

이더리움에서 토큰을 만들기를 정확하게 탐구하기 전에, 이더리움에서 토큰이 어떻게 작동하는지 에 대한 전체 오버뷰를 파악하는 것이 중요하다. 토큰은 이더와 다르다 왜냐하면 이더리움 프로토콜은 그들의 존재를 모르기 때문이다.(?) 이더 전송은 이더리움 플랫폼에서 내재된 행동이지만, 토큰을 소유하거나 전송하는 것은 아니다. 이더리움 계좌의 이더 잔고는 프로토콜 레벨에서 작동는데 비해, 토큰 잔고는 스마트 컨트랙트 레벨에서 작동된다. 이더리움에서 새로운 토큰을 만들기 위해서는 스마트 컨트랙트를 만들어야 한다. 한번 배포되면, 스마트 컨트랙트가 모든 것을 관리한다. 소유권, 전송, 접근 권한을 포함해서. 당신이 원하는 모든 기능을 수행할 수 있게 스마트 컨트랙트를 짤 수 있다, 그러나 현존하는 표준을 따르는 것이 바람직 할 것이다. 그런 표준들은 이후에 다룰 것이다. 챕터의 끝 부분에서 표준을 따르는 것의 득과 실에 대해서 다뤄보려고 한다.


[[ERC20_std]]
==== The ERC20 Token Standard

((("ERC20 token standard", id="ix_10tokens-asciidoc5", range="startofrange")))((("tokens","ERC20 standard", id="ix_10tokens-asciidoc6", range="startofrange")))The first standard was introduced in November 2015 by Fabian Vogelsteller as an Ethereum Request for Comments (ERC). It was automatically assigned GitHub issue number 20, giving rise to the name "ERC20 token." The vast majority of tokens are currently based on the ERC20 standard. The ERC20 request for comments eventually became Ethereum Improvement Proposal 20 (EIP-20), but it is mostly still referred to by the original name, ERC20.

ERC20 은 _fungible tokens_ 의 표준이다. 즉, 서로 다른 ERC 20 토큰들이 상호교환될 수 있고 unique properties 가 없다. 

http://bit.ly/2CUf7WG[The ERC20 standard] defines a common interface for contracts implementing a token, such that any compatible token can be accessed and used in the same way. The interface consists of a number of functions that must be present in every implementation of the standard, as well as some optional functions and attributes that may be added by developers.

[[ERC20_reqd_func]]
===== ERC20 required functions and events

((("ERC20 token standard","required functions and events"))) ERC20-호환 토큰 컨트랙트는 아래의 함수들과 이벤트를 최소한 제공해야 한다 : 

+totalSupply+:: Returns the total units of this token that currently exist. ERC20 tokens can have a fixed or a variable supply.

+balanceOf+:: Given an address, returns the token balance of that address.

+transfer+:: Given an address and amount, transfers that amount of tokens to that address, from the balance of the address that executed the transfer.

+transferFrom+:: Given a sender, recipient, and amount, transfers tokens from one account to another. Used in combination with +approve+.

+approve+:: Given a recipient address and amount, authorizes that address to execute several transfers up to that amount, from the account that issued the approval.

+allowance+:: Given an owner address and a spender address, returns the remaining amount that the spender is approved to withdraw from the owner.

+Transfer+:: Event triggered upon a successful transfer (call to +transfer+ or +transferFrom+) (even for zero-value transfers).

+Approval+:: Event logged upon a successful call to +approve+.

[[ERC20_optional_func]]
===== ERC20 optional functions

((("ERC20 token standard","optional functions")))In addition to the required functions listed in the previous section, the following optional functions are also defined by the standard:

+name+:: Returns the human-readable name (e.g., "US Dollars") of the token.

+symbol+:: Returns a human-readable symbol (e.g., "USD") for the token.

+decimals+:: Returns the number of decimals used to divide token amounts. For example, if +decimals+ is +2+, then the token amount is divided by 100 to get its user pass:[<span class="keep-together">representation</span>].

[[ERC20_interface]]
===== The ERC20 interface defined in Solidity

((("ERC20 token standard","interface defined in Solidity"))) 솔리디티에서 ERC 20 interface 스펙은 다음과 같다 :

[[ERC20_interface_example]]
[source,solidity]
----
contract ERC20 {
   function totalSupply() constant returns (uint theTotalSupply);
   function balanceOf(address _owner) constant returns (uint balance);
   function transfer(address _to, uint _value) returns (bool success);
   function transferFrom(address _from, address _to, uint _value) returns
      (bool success);
   function approve(address _spender, uint _value) returns (bool success);
   function allowance(address _owner, address _spender) constant returns
      (uint remaining);
   event Transfer(address indexed _from, address indexed _to, uint _value);
   event Approval(address indexed _owner, address indexed _spender, uint _value);
}
----

[[ERC20_data_struct]]
===== ERC20 data structures

((("data mapping")))((("ERC20 token standard","data structures"))) 모든 ERC 20 구현체를 보면 2가지 자료 구조를 발견할 것이다, 1개는 잔고를 추적하는 것 다른 하나는 비용(allowance)을 추적하는 것. 솔리디티에서는  _data mapping_ 으로 구현되어 있다.

첫 데이터 매핑 구현은 소유주에 따른 토큰 잔고를 나타내는 테이블이다. 이것이 누가 토큰을 소유했느냐를 계속 추적한다. 각 거래는 한 계좌에서 공제하여 다른 계좌에 더한다 : 

[[balance_mapping]]
[source,solidity]
----
mapping(address => uint256) balances;
----

2번째 자료구조는 소비(allowances)에 대한 매핑이다. 다음 섹션에서 보겠지만, ERC20 토큰으로 소유주는 소유주의 잔고에서 특정 금액(allowances)를 쓸 수 있게 해줌으로써, spender 에게 권한을 위임할 수 있다. ERC 20 컨트랙트는 토큰 소유주의 주소를 primary key로 두고 spender 주소 그리고 allowance 양으로 매핑하는 2차원 매핑을 통해 지속적으로 allowances 을 추적한다 :

[[allowance_mapping]]
[source,solidity]
----
mapping (address => mapping (address => uint256)) public allowed;
----


[[transfer_workflows]]
===== ERC20 workflows: "transfer" and "approve & transferFrom"

((("ERC20 token standard","transfer functions", id="ix_10tokens-asciidoc7", range="startofrange")))((("transfer function","ERC20 token standard", id="ix_10tokens-asciidoc8", range="startofrange")))The ERC20 token standard has two transfer functions. You might be wondering why.

ERC20 allows for two different workflows. The first is a single-transaction, straightforward workflow using the +transfer+ function. This workflow is the one used by wallets to send tokens to other wallets. The vast majority of token transactions happen with the +transfer+ workflow.

Executing the transfer contract is very simple. If Alice wants to send 10 tokens to Bob, her wallet sends a transaction to the token contract's address, calling the pass:[<span class="keep-together"><code>transfer</code></span>] function with Bob's address and +10+ as the arguments. The token contract adjusts Alice's balance (&#x2013;10) and Bob's balance (pass:[+10]) and issues a +Transfer+ event.

((("approve & transferFrom workflow")))The second workflow is a two-transaction workflow that uses +approve+ followed by +transferFrom+. This workflow allows a token owner to delegate their control to another address. It is most often used to delegate control to a contract for distribution of tokens, but it can also be used by exchanges.

((("Initial Coin Offerings (ICOs)","tokens and")))For example, if a company is selling tokens for an ICO, they can +approve+ a crowdsale contract address to distribute a certain amount of tokens. The crowdsale contract can then +transferFrom+ the token contract owner's balance to each buyer of the token, as illustrated in <<approve_transferFrom_workflow>>.

[NOTE]
====
((("Initial Coin Offerings (ICOs)","defined")))An _Initial Coin Offering_ (ICO) is a crowdfunding mechanism used by companies and organizations to raise money by selling tokens. The term is derived from Initial Public Offering (IPO), which is the process by which a public company offers shares for sale to investors on a stock exchange. Unlike the highly regulated IPO markets, ICOs are open, global, and messy. The examples and explanations of ICOs in this book are not an endorsement of this type of fundraising.
====

[[approve_transferFrom_workflow]]
.The two-step approve & transferFrom workflow of ERC20 tokens
image::images/approve_transferFrom_workflow.png["The two-step approve &amp; transferFrom workflow of ERC20 tokens"]

For the +approve+ & +transferFrom+ workflow, two transactions are needed. Let's say that Alice wants to allow the +AliceICO+ contract to sell 50% of all the AliceCoin tokens to buyers like Bob and Charlie. First, Alice launches the +AliceCoin+ ERC20 contract, issuing all the AliceCoin to her own address. Then, Alice launches the +AliceICO+ contract that can sell tokens for ether. Next, Alice initiates the +approve+ & +transferFrom+ workflow. She sends a transaction to the +AliceCoin+ contract, calling +approve+ with the address of the +AliceICO+ contract and 50% of the +totalSupply+ as arguments. This will trigger the +Approval+ event. Now, the +AliceICO+ contract can sell AliceCoin.

When the +AliceICO+ contract receives ether from Bob, it needs to send some AliceCoin to Bob in return. Within the +AliceICO+ contract is an exchange rate between AliceCoin and ether. The exchange rate that Alice set when she created the +AliceICO+ contract determines how many tokens Bob will receive for the amount of ether sent to the +AliceICO+ contract. When the +AliceICO+ contract calls the AliceCoin +transferFrom+ function, it sets Alice's address as the sender and Bob's address as the recipient, and uses the exchange rate to determine how many AliceCoin tokens will be transferred to Bob in the +value+ field. The +AliceCoin+ contract transfers the balance from Alice's address to Bob's address and triggers a +Transfer+ event. The +AliceICO+ contract can call +transferFrom+ an unlimited number of times, as long as it doesn't exceed the approval limit Alice set. The +AliceICO+ contract can keep track of how many AliceCoin tokens it can sell by calling the +allowance+ function.(((range="endofrange", startref="ix_10tokens-asciidoc8")))(((range="endofrange", startref="ix_10tokens-asciidoc7")))

[[ERC20_implementation]]
===== ERC20 implementations

While it is possible to implement an ERC20-compatible token in about 30 lines of Solidity code, most implementations are more complex. This is to account for potential security vulnerabilities. There are two implementations mentioned in the EIP-20 standard:

http://bit.ly/2EUYCMR[Consensys EIP20]:: A simple and easy-to-read implementation of an ERC20-compatible token.

https://bit.ly/2xPYck6[OpenZeppelin StandardToken]:: This implementation is ERC20-compatible, with additional security precautions. It forms the basis of OpenZeppelin libraries implementing more complex ERC20-compatible tokens with fundraising caps, auctions, vesting schedules, and other features.(((range="endofrange", startref="ix_10tokens-asciidoc6")))(((range="endofrange", startref="ix_10tokens-asciidoc5")))

[[METoken_example]]
==== Launching Our Own ERC20 Token

((("ERC20 token standard","METoken creation/launch example", id="ix_10tokens-asciidoc9", range="startofrange")))((("METoken (Mastering Ethereum Token)","creation/launch example", id="ix_10tokens-asciidoc10", range="startofrange")))Let's create and launch our own token. For this example, we will use the Truffle framework. The example assumes you have already installed +truffle+ and configured it, and are familiar with its basic operation (for details, see <<truffle>>).

We will call our token "Mastering Ethereum Token,&#x201d; with the symbol "MET."

[NOTE]
====
You can find this example https://github.com/ethereumbook/ethereumbook/blob/develop/code/truffle/METoken[in the book's GitHub repository].
====

First, let's create and initialize a Truffle project directory. Run these four commands and accept the default answers to any questions:

++++
<pre data-type="programlist">
$ <strong>mkdir METoken</strong>
$ <strong>cd METoken</strong>
METoken $ <strong>truffle init</strong>
METoken $ <strong>npm init</strong>
</pre>
++++

You should now have the following directory structure:

[[truffle_directory]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
`---- truffle.js
----

Edit the _truffle.js_ or _truffle-config.js_ configuration file to set up your Truffle environment, or copy the latter from http://bit.ly/2DdP2mz[the repository].

If you use the example _truffle-config.js_, remember to create a file _.env_ in the _METoken_ folder containing your test private keys for testing and deployment on public Ethereum test networks, such as Ropsten or Kovan. You can export your test network private key from MetaMask.

After that your directory should look like:

[[truffle_directory_metoken]]
----
METoken/
+---- contracts
|   `---- Migrations.sol
+---- migrations
|   `---- 1_initial_migration.js
+---- package.json
+---- test
+---- truffle-config.js
+---- truffle.js
`---- .env *new file*
----

[WARNING]
====
Only use test keys or test mnemonics that are _not_ used to hold funds on the main Ethereum network. _Never_ use keys that hold real money for testing.
====

For our example, we will import the OpenZeppelin library, which implements some important security checks and is easy to extend:

++++
<pre data-type="programlist">
$ <strong>npm install openzeppelin-solidity@1.12.0</strong>

+ openzeppelin-solidity@1.12.0
added 1 package from 1 contributor and audited 2381 packages in 4.074s
</pre>
++++

The +openzeppelin-solidity+ package will add about 250 files under the __node_modules__ directory. The OpenZeppelin library includes a lot more than the ERC20 token, but we will only use a small part of it.

Next, let's write our token contract. Create a new file, _METoken.sol_, and copy the example code from http://bit.ly/2qfIFH0[GitHub].

Our contract, shown in <<solidity_token_example>>, is very simple, as it inherits all its functionality from the OpenZeppelin library.

[[solidity_token_example]]
.METoken.sol: A Solidity contract implementing an ERC20 token
====
[source,solidity,linenums]
----
include::code/truffle/METoken/contracts/METoken.sol[]
----
====

Here, we are defining the optional variables +name+, +symbol+, and +decimals+. We also define an +_initial_supply+ variable, set to 21 million tokens; with two decimals of subdivision that gives 2.1 billion total units. In the contract's initialization (constructor) function we set the +totalSupply+ to be equal to +_initial_supply+ and allocate all of the +_initial_supply+ to the balance of the account (+msg.sender+) that creates the +METoken+ contract.

We now use +truffle+ to compile the +METoken+ code:

++++
<pre data-type="programlist">
$ <strong>truffle compile</strong>
Compiling ./contracts/METoken.sol...
Compiling ./contracts/Migrations.sol...
Compiling openzeppelin-solidity/contracts/math/SafeMath.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol...
Compiling openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol...
</pre>
++++

As you can see, +truffle+ incorporates necessary dependencies from the OpenZeppelin libraries and compiles those contracts too.

Let's set up a migration script to deploy the +METoken+ contract. Create a new file called __2_deploy_contracts.js__, in the _METoken/migrations_ folder. Copy the contents from the example http://bit.ly/2P0rHLl[in the GitHub repository]:


[[METoken_migration]]
.2_deploy_contracts: Migration to deploy METoken
[source,javascript,linenums]
----
include::code/truffle/METoken/migrations/2_deploy_contracts.js[]
----

Before we deploy on one of the Ethereum test networks, let's start a local blockchain to test everything. Start the +ganache+ blockchain, either from the command line with +ganache-cli+ or from the graphical user interface.

Once +ganache+ is started, we can deploy our +METoken+ contract and see if everything works as expected:

++++
<pre data-type="programlist">
$ <strong>truffle migrate --network ganache</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb2e90a056dc6ad8e654683921fc613c796a03b89df6760ec1db1084ea4a084eb
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying METoken...
  ... 0xbe9290d59678b412e60ed6aefedb17364f4ad2977cfb2076b9b8ad415c5dc9f0
  METoken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...
</pre>
++++

On the +ganache+ console, we should see that our deployment has created four new transactions, as depicted in <<ganache_METoken>>.

[[ganache_METoken]]
.METoken deployment on ganache
image::images/ganache_metoken.png["METoken deployment on Ganache"]

[[truffle_console]]
===== Interacting with METoken using the Truffle console

((("METoken (Mastering Ethereum Token)","interacting with via Truffle console", id="ix_10tokens-asciidoc11", range="startofrange")))((("Truffle","interacting with METoken via Truffle console", id="ix_10tokens-asciidoc12", range="startofrange")))We can interact with our contract on the +ganache+ blockchain using the Truffle console. This is an interactive JavaScript environment that provides access to the Truffle environment and, via web3, to the blockchain. In this case, we will connect the Truffle console to the +ganache+ blockchain:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt;
</pre>
++++

The +truffle(ganache)>+ prompt shows that we are connected to the +ganache+ blockchain and are ready to type our commands. The Truffle console supports all the +truffle+ commands, so we could +compile+ and +migrate+ from the console. We've already run those commands, so let's go directly to the contract itself. The +METoken+ contract exists as a JavaScript object within the Truffle environment. Type ++**METoken**++ at the prompt and it will dump the entire contract definition:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken</strong>
{ [Function: TruffleContract]
  _static_methods:

[...]

currentProvider:
 HttpProvider {
   host: 'http://localhost:7545',
   timeout: 0,
   user: undefined,
   password: undefined,
   headers: undefined,
   send: [Function],
   sendAsync: [Function],
   _alreadyWrapped: true },
network_id: '5777' }
</pre>
++++

The +METoken+ object also exposes several attributes, such as the address of the contract (as deployed by the +migrate+ command):

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.address</strong>
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
</pre>
++++

If we want to interact with the deployed contract, we have to use an asynchronous call, in the form of a JavaScript "promise." We use the +deployed+ function to get the contract instance and then call the +totalSupply+ function:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => instance.totalSupply())</strong>
BigNumber { s: 1, e: 9, c: [ 2100000000 ] }
</pre>
++++

Next, let's use the accounts created by +ganache+ to check our METoken balance and send some METoken to another address. First, let's get the account addresses:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>let accounts</strong>
undefined
truffle(ganache)&gt; <strong>web3.eth.getAccounts((err,res) => { accounts = res })</strong>
undefined
truffle(ganache)&gt; <strong>accounts[0]</strong>
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
</pre>
++++

The +accounts+ list now contains all the accounts created by +ganache+, and +account[0]+ is the account that deployed the +METoken+ contract. It should have a balance of pass:[<span class="keep-together">METoken</span>], because our METoken constructor gives the entire token supply to the address that created it. Let's check:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =></strong>
                  <strong>{ instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</strong>
</pre>
++++

Finally, let's transfer 1000.00 METoken from +account[0]+ to +account[1]+, by calling the contract's +transfer+ function:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.transfer(accounts[1], 100000) })</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[0]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2099900000 ] }</strong>
undefined
truffle(ganache)&gt; <strong>METoken.deployed().then(instance => 
                  { instance.balanceOf(accounts[1]).then(console.log) })</strong>
undefined
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

[TIP]
====
METoken has 2 decimals of precision, meaning that 1 METoken is 100 units in the contract. When we transfer 1,000 METoken, we specify the value as +100000+ in the call to the +transfer+ function.
====

As you can see, in the console, +account[0]+ now has 20,999,000 MET, and +account[1]+ has 1,000 MET.

If you switch to the +ganache+ graphical user interface, as shown in <<ganache_METoken_transfer>>, you will see the transaction that called the +transfer+ function.(((range="endofrange", startref="ix_10tokens-asciidoc12")))(((range="endofrange", startref="ix_10tokens-asciidoc11")))

[[ganache_METoken_transfer]]
.METoken transfer on ganache
image::images/ganache_metoken_transfer.png["METoken transfer on Ganache"]

[[sending_erc20_tokens_contracts]]
===== Sending ERC20 tokens to contract addresses

((("Faucet.sol contract (test example)","METoken project", id="ix_10tokens-asciidoc13", range="startofrange")))((("METoken (Mastering Ethereum Token)","sending to contract addresses", id="ix_10tokens-asciidoc14", range="startofrange")))So far, we've set up an ERC20 token and transferred some tokens from one account to another. All the accounts we used for these demonstrations are externally owned accounts, meaning they are controlled by a private key, not a contract. What happens if we send MET to a contract address? Let's find out!

First, let's deploy another contract into our test environment. For this example, we will use our first contract, _Faucet.sol_. Let's add it to the METoken project by copying it to the _contracts_ directory. Our directory should look like this:

[[METoken_directory]]
----
METoken/
+---- contracts
|   +---- Faucet.sol
|   +---- METoken.sol
|   `---- Migrations.sol
----

We'll also add a migration, to deploy +Faucet+ separately from +METoken+:

[[faucet_migration]]
[source,solidity]
----
var Faucet = artifacts.require("Faucet");

module.exports = function(deployer) {
  // Deploy the Faucet contract as our only task
  deployer.deploy(Faucet);
};
----

Let's compile and migrate the contracts from the Truffle console:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>compile</strong>
Compiling ./contracts/Faucet.sol...
Writing artifacts to ./build/contracts

truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9
  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba
  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f
Saving artifacts...
Running migration: 3_deploy_faucet.js
  Deploying Faucet...
  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3
  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524
Saving artifacts...
</pre>
++++

Great. Now let's send some MET to the +Faucet+ contract:

++++
<pre data-type="programlist">
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.transfer(Faucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(Faucet.address).then(console.log)})</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>
</pre>
++++

Alright, we have transferred 1,000 MET to the +Faucet+ contract. Now, how do we withdraw those tokens?

Remember, _Faucet.sol_ is a pretty simple contract. It only has one function, pass:[<span class="keep-together"><code>withdraw</code></span>], which is for withdrawing _ether_. It doesn't have a function for withdrawing MET, or any other ERC20 token. If we use +withdraw+ it will try to send ether, but since +Faucet+ doesn't have a balance of ether yet, it will fail.

The +METoken+ contract knows that +Faucet+ has a balance, but the only way that it can transfer that balance is if it receives a +transfer+ call from the address of the contract. Somehow we need to make the +Faucet+ contract call the +transfer+ function in pass:[<span class="keep-together"><code>METoken</code></span>].

If you're wondering what to do next, don't. There is no solution to this problem. The MET sent to +Faucet+ is stuck, forever. Only the +Faucet+ contract can transfer it, and the +Faucet+ contract doesn't have code to call the +transfer+ function of an ERC20 token contract.

Perhaps you anticipated this problem. Most likely, you didn't. In fact, neither did hundreds of Ethereum users who accidentally transferred various tokens to contracts that didn't have any ERC20 capability. According to some estimates, tokens worth more than roughly $2.5 million USD (at the time of writing) have gotten "stuck" like this and are lost forever.

One of the ways that users of ERC20 tokens can inadvertently lose their tokens in a transfer, is when they attempt to transfer to an exchange or another service. They copy an Ethereum address from the website of an exchange, thinking they can simply send tokens to it. However, many exchanges publish receiving addresses that are actually contracts! These contracts are only meant to receive ether, not ERC20 tokens, most often sweeping all funds sent to them to "cold storage" or another centralized wallet. Despite the many warnings saying "do not send tokens to this address," lots of tokens are lost this way.(((range="endofrange", startref="ix_10tokens-asciidoc14")))(((range="endofrange", startref="ix_10tokens-asciidoc13")))

[[transfer_workflow_demo]]
===== Demonstrating the &#x201c;approve & transferFrom&#x201d; workflow

((("approve & transferFrom workflow", id="ix_10tokens-asciidoc15", range="startofrange")))((("Faucet.sol contract (test example)","METoken approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc16", range="startofrange")))((("METoken (Mastering Ethereum Token)","approve & transferFrom workflow demonstration", id="ix_10tokens-asciidoc17", range="startofrange")))Our +Faucet+ contract couldn't handle ERC20 tokens. Sending tokens to it using the +transfer+ function resulted in the loss of those tokens. Let's rewrite the contract now and make it handle ERC20 tokens. Specifically, we will turn it into a faucet that gives out MET to anyone who asks.

For this example, we'll make a copy of the _truffle_ project directory (we'll call it __METoken_METFaucet__), initialize +truffle+ and +npm+, install the OpenZeppelin dependencies, and copy the _METoken.sol_ contract. See our first example, in <<METoken_example>>, for the detailed instructions.

Our new faucet contract, _METFaucet.sol_, will look like <<METFaucet>>.

[[METFaucet]]
.METFaucet.sol: A faucet for METoken
====
[source,solidity,linenums]
----
include::code/truffle/METoken_METFaucet/contracts/METFaucet.sol[]
----
====

We've made quite a few changes to the basic +Faucet+ example. Since +METFaucet+ will use the +transferFrom+ function in +METoken+, it will need two additional variables. One will hold the address of the deployed +METoken+ contract. The other will hold the address of the owner of the MET, who will approve the faucet withdrawals. The +METFaucet+ contract will call +METoken.transferFrom+ and instruct it to move MET from the owner to the address where the faucet withdrawal request came from.


We declare these two variables here:

[source,solidity]
----
StandardToken public METoken;
address public METOwner;
----

Since our faucet needs to be initialized with the correct addresses for +METoken+ and +METOwner+, we need to declare a custom constructor:

[[custom_constructor]]
[source,solidity]
----
// METFaucet constructor - provide the address of the METoken contract and
// the owner address we will be approved to transferFrom
function METFaucet(address _METoken, address _METOwner) public {

	// Initialize the METoken from the address provided
	METoken = StandardToken(_METoken);
	METOwner = _METOwner;
}
----

The next change is to the +withdraw+ function. Instead of calling +transfer+, +METFaucet+ uses the +transferFrom+ function in +METoken+ and asks +METoken+ to transfer MET to the faucet recipient:

[[transfer_met]]
[source,solidity]
----
// Use the transferFrom function of METoken
METoken.transferFrom(METOwner, msg.sender, withdraw_amount);
----

Finally, since our faucet no longer sends ether, we should probably prevent anyone from sending ether to +METFaucet+, as we wouldn't want it to get stuck. We change the fallback payable function to reject incoming ether, using the +revert+ function to revert any incoming payments:

[[reject_incoming_eth]]
[source,solidity]
----
// REJECT any incoming ether
function () public payable { revert(); }
----

Now that our _METFaucet.sol_ code is ready, we need to modify the migration script to deploy it. This migration script will be a bit more complex, as +METFaucet+ depends on the address of +METoken+. We will use a JavaScript promise to deploy the two contracts in sequence. Create __2_deploy_contracts.js__ as follows:

[source,solidity]
----
var METoken = artifacts.require("METoken");
var METFaucet = artifacts.require("METFaucet");
var owner = web3.eth.accounts[0];

module.exports = function(deployer) {

	// Deploy the METoken contract first
	deployer.deploy(METoken, {from: owner}).then(function() {
		// Then deploy METFaucet and pass the address of METoken and the
		// address of the owner of all the MET who will approve METFaucet
		return deployer.deploy(METFaucet, METoken.address, owner);
  	});
}
----

Now, we can test everything in the Truffle console. First, we use +migrate+ to deploy the contracts. When +METoken+ is deployed it will allocate all the MET to the account that created it, +web3.eth.accounts[0]+. Then, we call the +approve+ function in pass:[<code><span class="keep-together">METoken</span></code>] to approve +METFaucet+ to send up to 1,000 MET on behalf of +web3.eth.accounts[0]+. Finally, to test our faucet, we call +METFaucet.withdraw+ from +web3.eth.accounts[1]+ and try to withdraw 10 MET. Here are the console commands:

++++
<pre data-type="programlist">
$ <strong>truffle console --network ganache</strong>
truffle(ganache)&gt; <strong>migrate</strong>
Using network 'ganache'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x79352b43e18cc46b023a779e9a0d16b30f127bfa40266c02f9871d63c26542c7
  Migrations: 0xaa588d3737b611bafd7bd713445b314bd453a5c8
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Replacing METoken...
  ... 0xc42a57f22cddf95f6f8c19d794c8af3b2491f568b38b96fef15b13b6e8bfff21
  METoken: 0xf204a4ef082f5c04bb89f7d5e6568b796096735a
  Replacing METFaucet...
  ... 0xd9615cae2fa4f1e8a377de87f86162832cf4d31098779e6e00df1ae7f1b7f864
  METFaucet: 0x75c35c980c0d37ef46df04d31a140b65503c0eed
Saving artifacts...
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.approve(METFaucet.address, 100000) })</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 0, c: [ 0 ] }</strong>
truffle(ganache)&gt; <strong>METFaucet.deployed().then(instance =>
                  { instance.withdraw(1000, {from:web3.eth.accounts[1]}) } )</strong>
truffle(ganache)&gt; <strong>METoken.deployed().then(instance =>
                  { instance.balanceOf(web3.eth.accounts[1]).then(console.log) })</strong>
truffle(ganache)&gt; <strong>BigNumber { s: 1, e: 3, c: [ 1000 ] }</strong>
</pre>
++++

As you can see from the results, we can use the +approve+ &amp; +transferFrom+ workflow to authorize one contract to transfer tokens defined in another token. If properly used, ERC20 tokens can be used by EOAs and other contracts.

However, the burden of managing ERC20 tokens correctly is pushed to the user interface. If a user incorrectly attempts to transfer ERC20 tokens to a contract address and that contract is not equipped to receive ERC20 tokens, the tokens will be lost(((range="endofrange", startref="ix_10tokens-asciidoc17")))(((range="endofrange", startref="ix_10tokens-asciidoc16")))(((range="endofrange", startref="ix_10tokens-asciidoc15"))).(((range="endofrange", startref="ix_10tokens-asciidoc10")))(((range="endofrange", startref="ix_10tokens-asciidoc9")))

[[ERC20_issues]]
==== Issues with ERC20 Tokens

((("ERC20 token standard","issues with ERC20 tokens")))The adoption of the ERC20 token standard has been truly explosive. Thousands of tokens have been launched, both to experiment with new capabilities and to raise funds in various "crowdfund" auctions and ICOs. However, there are some potential pitfalls, as we saw with the issue of transferring tokens to contract addresses.

One of the less obvious issues with ERC20 tokens is that they expose subtle differences between tokens and ether itself. Where ether is transferred by a transaction that has a recipient address as its destination, token transfers occur within the _specific token contract state_ and have the token contract as their destination, not the recipient's address. The token contract tracks balances and issues events. In a token transfer, no transaction is actually sent to the recipient of the token. Instead, the recipient's address is added to a map within the token contract itself. A transaction sending ether to an address changes the state of an address. A transaction transferring a token to an address only changes the state of the token contract, not the state of the recipient address. Even a wallet that has support for ERC20 tokens does not become aware of a token balance unless the user explicitly adds a specific token contract to "watch." Some wallets watch the most popular token contracts to detect balances held by addresses they control, but that's limited to a small fraction of existing ERC20 pass:[<span class="keep-together">contracts</span>].

In fact, it's unlikely that a user would _want_ to track all balances in all possible ERC20 token contracts. Many ERC20 tokens are more like email spam than usable tokens. They automatically create balances for accounts that have ether activity, in order to attract users. If you have an Ethereum address with a long history of activity, especially if it was created in the presale, you will find it full of "junk" tokens that appeared out of nowhere. Of course, the address isn't really full of tokens; it's the token contracts that have your address in them. You only see these balances if these token contracts are being watched by the block explorer or wallet you use to view your address.

Tokens don't behave the same way as ether. Ether is sent with the +send+ function and accepted by any payable function in a contract or any externally owned address. Tokens are sent using +transfer+ or +approve+ & +transferFrom+ functions that exist only in the ERC20 contract, and do not (at least in ERC20) trigger any payable functions in a recipient contract. Tokens are meant to function just like a cryptocurrency such as ether, but they come with certain differences that break that illusion.

((("gas","tokens and")))((("tokens","gas and")))Consider another issue. To send ether or use any Ethereum contract you need ether to pay for gas. To send tokens, you _also need ether_. You cannot pay for a transaction's gas with a token and the token contract can't pay for the gas for you. This may change at some point in the distant future, but in the meantime this can cause some rather strange user experiences. For example, let's say you use an exchange or ShapeShift to convert some bitcoin to a token. You "receive" the token in a wallet that tracks that token's contract and shows your balance. It looks the same as any of the other cryptocurrencies you have in your wallet. Try sending the token, though, and your wallet will inform you that you need ether to do that. You might be confused&#x2014;after all, you didn't need ether to receive the token. Perhaps you have no ether. Perhaps you didn't even know the token was an ERC20 token on Ethereum; maybe you thought it was a cryptocurrency with its own blockchain. The illusion just broke.

이 이슈들 중 몇개는 ERC 20 토큰에 대한 것들이다. 나머지는 abstraction , interface boundaries 같이 이더리움과 관련된 더욱 일반적인 것들이다. 몇몇은 토큰 인터페이스를 바꿈으로써 해결되고, 몇몇은 이더리움의 근본적인 구조를 바꾸자고 하는 것 들이다.(EOA 와 컨트랙트 구별 그리고 트랜잭션과 메세지차이) 몇가지들은 "해결되기" 어려운 것들이다 그리고 UI 디자인을 뉘앙스를 숨기게 하자고 하던가 기본 구별과 관계없이 UX 를 통일시키자고 하자고 한다.(?)

다음 섹션에서는 이 문제들을 해결하기 위한 다양한 제안들을 살펴보겠다. 

[[ERC223_std]]
==== ERC223: A Proposed Token Contract Interface Standard

((("ERC223 token standard proposal")))((("tokens","ERC223 standard proposal")))ERC223 수신지( 도착 주소? destination address)가 컨트랙트인지 아닌지 확인함으로써 컨트랙트로의 부주의한 토큰 전송 문제를 해결하려고 제안되었다. (that may or may not support tokens) ERC223은 토큰을 받게 설계된 컨트랙트는 +tokenFallback+ 이라는 함수를 도입하자고 제안한다. 만약 수신지가 컨트랙트인데 토큰에 대한 서포트를 하지 않으면(아니면, +tokenFallback+ 함수가 없으면), 그 전송은 실패한다.

[[is_contract]]
수신지가 컨트랙트인지 확인하기 위해서, ERC223 참조 구현은 다소 독창적인 방법으로 인라인 바이트 코드의 작은 세그먼트를 사용했다.

[source,solidity]
----
function isContract(address _addr) private view returns (bool is_contract) {
  uint length;
    assembly {
       // retrieve the size of the code on target address; this needs assembly
       length := extcodesize(_addr)
    }
    return (length>0);
}
----

[[ERC223_interface]]
The ERC223 contract interface specification is:

[source,solidity]
----
interface ERC223Token {
  uint public totalSupply;
  function balanceOf(address who) public view returns (uint);

  function name() public view returns (string _name);
  function symbol() public view returns (string _symbol);
  function decimals() public view returns (uint8 _decimals);
  function totalSupply() public view returns (uint256 _supply);

  function transfer(address to, uint value) public returns (bool ok);
  function transfer(address to, uint value, bytes data) public returns (bool ok);
  function transfer(address to, uint value, bytes data, string custom_fallback)
      public returns (bool ok);

  event Transfer(address indexed from, address indexed to, uint value,
                 bytes indexed data);
}
----

ERC223 is not widely implemented, and there is some debate in https://github.com/ethereum/EIPs/issues/223[the ERC discussion] thread about backward compatibility and trade-offs between implementing changes at the contract interface level versus the user interface. The debate continues.

==== ERC777: A Proposed Token Contract Interface Standard

((("ERC777 token standard proposal", id="ix_10tokens-asciidoc18", range="startofrange")))((("tokens","ERC777 standard proposal", id="ix_10tokens-asciidoc19", range="startofrange")))개선된 토큰 컨트랙트 표준을 위한 또다른 제안은 https://eips.ethereum.org/EIPS/eip-777[ERC777] 이다. 이 제안은 여러가지 목표를 가지고 있다 : 

* ERC20와 호환가능한 interface 제공한다
* 토큰을 전송하려면 +send+ 기능을 사용한다 , 이더 전송과 비슷하다 
* 토큰 컨트랙트 등록을 위헤 ERC820 와 호환가능하게 한다. 
* To allow contracts and addresses to control which tokens they send through a `tokensToSend` function that is called prior to sending
* To enable contracts and addresses to be notified of the tokens' receipt by calling a `tokensReceived` function in the recipient, and to reduce the probability of tokens being locked into contracts by requiring contracts to provide a pass:[<span class="keep-together"><code>tokensReceived</code></span>] function
* To allow existing contracts to use proxy contracts for the +tokensToSend+ and +tokensReceived+ functions
* To operate in the same way whether sending to a contract or an EOA
* To provide specific events for the minting and burning of tokens
* To enable operators (trusted third parties, intended to be verified contracts) to move tokens on behalf of a token holder
* To provide metadata on token transfer transactions in +userData+ and +operatorData+ fields

The ongoing discussion on ERC777 can be found https://github.com/ethereum/EIPs/issues/777[on GitHub].

[[ERC777_interface]]
The ERC777 contract interface specification is:

[source,solidity]
----
interface ERC777Token {
    function name() public constant returns (string);
    function symbol() public constant returns (string);
    function totalSupply() public constant returns (uint256);
    function granularity() public constant returns (uint256);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 amount, bytes userData) public;

    function authorizeOperator(address operator) public;
    function revokeOperator(address operator) public;
    function isOperatorFor(address operator, address tokenHolder)
        public constant returns (bool);
    function operatorSend(address from, address to, uint256 amount,
                          bytes userData,bytes operatorData) public;

    event Sent(address indexed operator, address indexed from,
               address indexed to, uint256 amount, bytes userData, 
               bytes operatorData);
    event Minted(address indexed operator, address indexed to,
                 uint256 amount, bytes operatorData);
    event Burned(address indexed operator, address indexed from,
                 uint256 amount, bytes userData, bytes operatorData);
    event AuthorizedOperator(address indexed operator,
                             address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
}
----

[[ERC777_hooks]]
===== ERC777 hooks

[[ERC777TokensSender_interface]]
The ERC777 tokens sender hook specification is:

[source,solidity]
----
interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to,
                          uint value, bytes userData, bytes operatorData) public;
}
----

The implementation of this interface is required for any address wishing to be notified of, to handle, or to prevent the debit of tokens. The address for which the contract implements this interface must be registered via ERC820, whether the contract implements the interface for itself or for another address.

[[ERC777TokensRecipient_interface]]
The ERC777 tokens recipient hook specification is:

[source,solidity]
----
interface ERC777TokensRecipient {
  function tokensReceived(
     address operator, address from, address to,
    uint amount, bytes userData, bytes operatorData
  ) public;
}
----

The implementation of this interface is required for any address wishing to be notified of, to handle, or to reject the reception of tokens. The same logic and requirements apply to the tokens recipient as to the tokens sender interface, with the added constraint that recipient contracts must implement this interface to prevent locking tokens. If the recipient contract does not register an address implementing this interface, the transfer of tokens will fail.

An important aspect is that only one token sender and one token recipient can be registered per address. Hence, for every ERC777 token transfer the same hook functions are called upon debit and reception of every ERC777 token transfer. A specific token can be identified in these functions using the message's sender, which is the specific token contract address, to handle a particular use case.

On the other hand, the same token sender and token recipient hooks can be registered for multiple addresses and the hooks can distinguish who are the sender and the intended recipient using the `from` and `to` parameters.

A http://bit.ly/2qkAKba[reference implementation] of ERC777 is linked in the proposal. ERC777 depends on a parallel proposal for a registry contract, specified in ERC820. Some of the debate on ERC777 is about the complexity of adopting two big changes at once: a new token standard and a registry standard. The discussion continues.(((range="endofrange", startref="ix_10tokens-asciidoc19")))(((range="endofrange", startref="ix_10tokens-asciidoc18")))

[[erc721]]
==== ERC721: Non-fungible Token (Deed) Standard

((("deed","and ERC721 non-fungible token standard", id="ix_10tokens-asciidoc20", range="startofrange")))((("ERC721 non-fungible token standard", id="ix_10tokens-asciidoc21", range="startofrange")))((("non-fungible tokens (NFTs)","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc22", range="startofrange")))((("tokens","ERC721 non-fungible token standard", id="ix_10tokens-asciidoc23", range="startofrange")))지금까지 살펴보았던 토큰들은 모두 _fungible_ 했다. 즉, 토큰 단위로 상호교환이 가능했었다. ERC 20 토큰 표준은 각 계정의 마지막 잔고(final balance)만 추적하고 (명시적으로) 그 어떤 토큰의 출처를 추적하지 않습니다.

((("deed","defined"))) http://bit.ly/2Ogs7Im[ERC721 proposal] 은 _non-fungible_ 토큰들의 표준이다, 또한 _deeds_ 으로 알려져 있다.

Oxford 사전에 의하면:

____
_deed_: A legal document that is signed and delivered, especially one regarding the ownership of property or legal rights.
____

단어 "deed"은 "자산의 소유권" 부분을 반영하기 위해서 사용되었다, 비록 아직 그 어떤 jurisdiction에도 "법적인 문서"로 표기된 것은 존재하지 않는다. 그러나 가까운 미래에, 블록체인 플랫폼 상의 디지털 서명을 기반으로한 법적인 소유권도 법적으로 인정될 것 같다. 

NFT 유일한 것(unique thing)의 소유권을 추적한다. 소유될 수 있는 것은 게임 아이템 또는 디지털 소장품 같은 디지털 상품일수도 있고 소유권이 토큰으로 추적이 가능한 집 , 차 , 미술 작품처럼 물리적인 것일 수도 있다. Deeds는 빚(부채), lien , easement 기타 등등 음수 값도 다룰 수 있다. ERC 721 표준은 deed 에 의해 소유권이 추적되는 모든 것들에 대해서 한계나 expectation을 두지 않고 유일하게 식별될 수 있는 것만을 요구한다. 이 표준에서는 256 비트    pass:[<span class="keep-together">identifier</span>] achieved 된다.

The details of the standard and discussion are tracked in two different GitHub pass:[<span class="keep-together">locations</span>]:

* https://github.com/ethereum/EIPs/issues/721[Initial proposal]

* https://github.com/ethereum/EIPs/pull/841[Continued discussion]

[[map_deed_owner]]
ERC20 와 ERC721의 근본적인 차이점을 찾으려면, ERC 721에서 사용되는 그 내부 자료구조를 보는 것으로 충분하다 : 

[source,solidity]
----
// Mapping from deed ID to owner
mapping (uint256 => address) private deedOwner;
----

Whereas ERC20 tracks the balances that belong to each owner, with the owner being the primary key of the mapping, ERC721 tracks each deed ID and who owns it, with the deed ID being the primary key of the mapping. From this basic difference flow all the properties of a non-fungible token.

[[ERC721_interface]]
The ERC721 contract interface specification is:

[source,solidity]
----
interface ERC721 /* is ERC165 */ {
    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);
    event Approval(address indexed _owner, address indexed _approved,
                   uint256 _deedId);
    event ApprovalForAll(address indexed _owner, address indexed _operator,
                         bool _approved);

    function balanceOf(address _owner) external view returns (uint256 _balance);
    function ownerOf(uint256 _deedId) external view returns (address _owner);
    function transfer(address _to, uint256 _deedId) external payable;
    function transferFrom(address _from, address _to, uint256 _deedId)
        external payable;
    function approve(address _approved, uint256 _deedId) external payable;
    function setApprovalForAll(address _operateor, boolean _approved) payable;
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
----

ERC721 also supports two _optional_ interfaces, one for metadata and one for enumeration of deeds and owners.

[[ERC721_metadata]]
The ERC721 optional interface for metadata is:

[source,solidity]
----
interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function deedUri(uint256 _deedId) external view returns (string _deedUri);
}
----

[[ERC721_enum]]
The ERC721 optional interface for enumeration is(((range="endofrange", startref="ix_10tokens-asciidoc23")))(((range="endofrange", startref="ix_10tokens-asciidoc22")))(((range="endofrange", startref="ix_10tokens-asciidoc21")))(((range="endofrange", startref="ix_10tokens-asciidoc20"))):(((range="endofrange", startref="ix_10tokens-asciidoc4")))

[source,solidity]
----
interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256 _count);
    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);
    function countOfOwners() external view returns (uint256 _count);
    function ownerByIndex(uint256 _index) external view returns (address _owner);
    function deedOfOwnerByIndex(address _owner, uint256 _index) external view
        returns (uint256 _deedId);
}
----

[[token_std_review]]
=== Using Token Standards

((("token standards (generally)", seealso="specific standards, e.g.: ERC20 token standard", id="ix_10tokens-asciidoc24", range="startofrange")))((("tokens","using token standards", id="ix_10tokens-asciidoc25", range="startofrange")))In the previous section we reviewed several proposed standards and a couple of widely deployed standards for token contracts. What exactly do these standards do? Should you use these standards? How should you use them? Should you add functionality beyond these standards? Which standards should you use? We will examine some of those questions next.

[[token_std_purpose]]
==== What Are Token Standards? What Is Their Purpose?

((("token standards (generally)","defined")))Token standards are the _minimum_ specifications for an implementation. What that means is that in order to be compliant with, say, ERC20, you need to at minimum implement the functions and behavior specified by the ERC20 standard. You are also free to _add_ to the functionality by implementing functions that are not part of the standard.

((("token standards (generally)","purpose of")))The primary purpose of these standards is to encourage _interoperability_ between contracts. Thus, all wallets, exchanges, user interfaces, and other infrastructure components can _interface_ in a predictable manner with any contract that follows the specification. In other words, if you deploy a contract that follows the ERC20 standard, all existing wallet users can seamlessly start trading your token without any wallet upgrade or effort on your part.

The standards are meant to be _descriptive_, rather than _prescriptive_. How you choose to implement those functions is up to you&#x2014;the internal functioning of the contract is not relevant to the standard. They have some functional requirements, which govern the behavior under specific circumstances, but they do not prescribe an implementation. An example of this is the behavior of a +transfer+ function if the value is set to zero.

[[should_use_std]]
==== Should You Use These Standards?

((("token standards (generally)","reasons to use")))Given all these standards, each developer faces a dilemma: use the existing standards or innovate beyond the restrictions they impose?

This dilemma is not easy to resolve. Standards necessarily restrict your ability to innovate, by creating a narrow "rut" that you have to follow. On the other hand, the basic standards have emerged from experience with hundreds of applications and often fit well with the vast majority of use cases.

As part of this consideration is an even bigger issue: the value of interoperability and broad adoption. If you choose to use an existing standard, you gain the value of all the systems designed to work with that standard. If you choose to depart from the standard, you have to consider the cost of building all of the support infrastructure on your own, or persuading others to support your implementation as a new standard. The tendency to forge your own path and ignore existing standards is known as "Not Invented Here" syndrome and is antithetical to open source culture. On the other hand, progress and innovation depend on departing from tradition sometimes. It's a tricky choice, so consider it carefully!

[NOTE]
====
Per Wikipedia, https://en.wikipedia.org/wiki/Not_invented_here[&#x201c;Not Invented Here&#x201d;] is a stance adopted by social, corporate, or institutional cultures that avoid using or buying already existing products, research, standards, or knowledge because of their external origins and costs, such as royalties.
====


[[security_maturity]]
==== Security by Maturity

((("security (smart contracts)","token standard implementation choices")))((("token standards (generally)","implementation choices")))Beyond the choice of standard, there is the parallel choice of _implementation_. When you decide to use a standard such as ERC20, you have to then decide how to implement a compatible design. There are a number of existing "reference" implementations that are widely used in the Ethereum ecosystem, or you could write your own from scratch. Again, this choice represents a dilemma that can have serious security implications.

Existing implementations are &#x201c;battle-tested.&#x201d; While it is impossible to prove that they are secure, many of them underpin millions of dollars' worth of tokens. They have been attacked, repeatedly and vigorously. So far, no significant vulnerabilities have been discovered. Writing your own is not easy&#x2014;there are many subtle ways that a contract can be compromised. It is much safer to use a well-tested, widely used implementation. In our examples, we used the OpenZeppelin implementation of the ERC20 standard, as this implementation is security-focused from the ground up.

If you use an existing implementation you can also extend it. Again, however, be careful with this impulse. Complexity is the enemy of security. ((("attack surface")))Every single line of code you add expands the _attack surface_ of your contract and could represent a vulnerability lying in wait. You may not notice a problem until you put a lot of value on top of the contract and someone breaks it.

[TIP]
====
Standards and implementation choices are important parts of overall secure smart contract design, but they're not the only considerations. See <<smart_contract_security>>.(((range="endofrange", startref="ix_10tokens-asciidoc25")))(((range="endofrange", startref="ix_10tokens-asciidoc24")))
====


[[extend_token_interface]]
=== Extensions to Token Interface Standards

((("token standards (generally)","extensions to")))The token standards discussed in this chapter provide a very minimal interface, with limited functionality. Many projects have created extended implementations to support features that they need for their applications. Some of these features include:

Owner control:: The ability to give specific addresses, or sets of addresses (i.e., multisignature schemes), special capabilities, such as blacklisting, whitelisting, minting, recovery, etc.

Burning:: The ability to deliberately destroy (&#x201c;burn&#x201d;) tokens by transferring them to an unspendable address or by erasing a balance and reducing the supply.

Minting:: The ability to add to the total supply of tokens, at a predictable rate or by "fiat" of the creator of the token.

Crowdfunding:: The ability to offer tokens for sale, for example through an auction, market sale, reverse auction, etc.

Caps:: The ability to set predefined and immutable limits on the total supply (the opposite of the "minting" feature).

Recovery backdoors:: Functions to recover funds, reverse transfers, or dismantle the token that can be activated by a designated address or set of addresses.

Whitelisting:: The ability to restrict actions (such as token transfers) to specific addresses. Most commonly used to offer tokens to "accredited investors" after vetting by the rules of different jurisdictions. There is usually a mechanism for updating the whitelist.

Blacklisting:: The ability to restrict token transfers by disallowing specific addresses. There is usually a function for updating the blacklist.

There are reference implementations for many of these functions, for example in the OpenZeppelin library. Some of these are use case–specific and only implemented in a few tokens. There are, as of now, no widely accepted standards for the interfaces to these functions.

As previously discussed, the decision to extend a token standard with additional functionality represents a trade-off between innovation/risk and interoperability/security.

[[tokens_ico]]
=== 토큰 & ICO (Tokens and ICOs)

((("Initial Coin Offerings (ICOs)","tokens and")))((("tokens","ICOs and")))토큰은 이더리움 생태계에서 폭발적인 발전을 해왔다. 그들으 이더리움과 같은 스마트 컨트랙트 플랫폼에서 매우 중요한 요인이 될 것이다. 

그렇지만, 이런 표준들의 중요성과 미래 영향력 (the importance and future impact of these standards)과 현재으 토큰 지급 보증과 헷갈리며 안된다.(?) 모든 기술의 초기단게에서 상품과 회사의 첫 시작(fist wave)은 대부분 실패할 것이다, 그리고 몇은 엄청나게(spectaacularly) 실패한다. 이더리움에서 지급되는 다수의 토큰들은 스캠, 피라미드 사기 그리고 갈취로 위장되어 있다.(?) 

트릭은(?) 장기간 비젼과 엄청날 기술의 영향력을 단기간의 토큰 ICO 거품으로부터 분리하는 것이다. 토큰 표준과 플랫폼은 현 토큰 열풍 속에서 살아날 것이고 그들은 세상을 바꿀 것이다.

=== 결론 

토큰은 이더리움에서 매우 powerful 한 개념이고 많은 중요한 Dapp의 기반들을 형성할 수 있게 한다. 이번 단원에서는 다양한 종류들의 토큰들과 트콘 기준들을 살펴보았다, 그리고 당신의 첫 토큰과 그에 관련된 어플리케이션을 만들었다. 토큰들에 대해서는 옥션 DApp에 non-fungible 한 토큰을 활용할 <<decentralized_applications_chap>>에서 다시 살펴볼 것이다.(((range="endofrange", startref="ix_10tokens-asciidoc0")))
